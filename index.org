#+TITLE: s7 playground
# #+SUBTITLE: Try s7 scheme in your browser
#+PROPERTY: header-args:scheme :exports both :eval never-export :wrap export html
# the org-babel-execute:scheme is modded so that it outputs html with the
# evaluation result, stdout and stderr
#+OPTIONS: html-style:nil
#+OPTIONS: toc:nil
#+OPTIONS: html-postamble:nil
# see https://orgmode.org/manual/Publishing-options.html
#+OPTIONS: num:nil

# -- codemirror
#+HTML_HEAD: <script type="text/javascript" src="libs/codemirror/lib/codemirror.js"></script>
#+HTML_HEAD: <link rel="stylesheet" href="libs/codemirror/lib/codemirror.css">
#+HTML_HEAD: <link rel="stylesheet" href="libs/codemirror/theme/monokai.css">
#+HTML_HEAD: <script type="text/javascript" src="libs/codemirror/mode/scheme.js"></script>
# codemirror addons
#+HTML_HEAD: <script type="text/javascript" src="libs/codemirror/addon/edit/matchbrackets.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="libs/codemirror/addon/edit/closebrackets.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="libs/codemirror/addon/selection/active-line.js"></script>
# -- parinfer
#+HTML_HEAD: <script type="text/javascript" src="libs/parinfer.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="libs/parinfer-codemirror.js"></script>
# -- our stuf
#+HTML_HEAD: <script type="text/javascript" src="build/s7_wasm.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="js/s7-playground.js"></script>
#+HTML_HEAD: <link rel='stylesheet' type='text/css' href='css/style.css'/>

A work-in-progress interactive tutorial of =s7 scheme=. For a more complete manual please refer to https://ccrma.stanford.edu/software/snd/snd/s7.html

* Intro
  #+BEGIN_SRC scheme
;; these are some comments
(display "Hello there!!") ;; stdout is displayed with blue background
(+ 1 2 3) ;; output is displayed in gray background
this-will-cause-an-error ;; will cause an error. comment this line and you'll see "6" in the output
;; stderr is displayed in red background
  #+END_SRC

  #+RESULTS:
  #+BEGIN_export html
  <div class='eval-result'>
  <pre class='res'>unbound-variable</pre>
  <pre class='out'>Hello there!!</pre>
  <pre class='err'>
  ;unbound variable this-will-cause-an-error in this-will-cause-an-error
  </pre>
  </div>
  #+END_export

* Math
  s7 includes:
  - sinh, cosh, tanh, asinh, acosh, atanh
  - logior, logxor, logand, lognot, logbit?, ash, integer-decode-float
  - random
  - nan?, infinite?

  #+BEGIN_SRC scheme :results value verbatim :exports both
(list
 (cos 0)
 (sin 0)
 (random 100))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_export html
  <div class='eval-result'>
  <pre class='res'>(1 0 32)</pre>
  <pre class='out'></pre>
  <pre class='err'></pre>
  </div>
  #+END_export


  # TODO remove: just showcasing that when we don't already have any results, they get created from javascript
  #+BEGIN_SRC scheme :results value verbatim :exports both
(list
 (cos 0)
 (sin 0)
 (random 1000))
  #+END_SRC

* define*, lambda*
  =define*= and =lambda*= are extensions of define and lambda that
  make it easier to deal with optional, keyword, and rest
  arguments.

  The syntax is very simple: every argument to =define*= has a default
  value and is automatically available as a keyword argument. The
  default value is either =#f= if unspecified, or given in a list
  whose first member is the argument name. The last argument can be
  preceded by =:rest= or a dot =.= to indicate that all other trailing
  arguments should be packaged as a list under that argument's name. A
  trailing or rest argument's default value is =()= and can't be
  specified in the declaration. The rest argument is *not* available as
  a keyword argument.

  #+BEGIN_SRC scheme :exports both
(define*
 ;; function name: hi
 ;; a is needed
 ;; b has default argument 32
 ;; c has default argument "hi"
 (hi a (b 32) (c "hi"))
 ;; just returning the arguments
 (list a b c))

(list
 (hi 1)
 (hi :b 2 :a 3)
 (hi 3 2 1))
  #+END_SRC

  #+RESULTS:
  #+BEGIN_export html
  <div class='eval-result'>
  <pre class='res'>((1 32 &quot;hi&quot;) (3 2 &quot;hi&quot;) (3 2 1))</pre>
  <pre class='out'></pre>
  <pre class='err'></pre>
  </div>
  #+END_export

* Macros
  #+BEGIN_SRC scheme
(define-macro (repl-examples . args)
  `(for-each (lambda (exp)
	       (format #t "~A\n;; => ~A\n" exp (eval exp)))
	     ',args))

(repl-examples
 (+ 1 2 1)
 (/ 10 2)
 )
  #+END_SRC

  #+RESULTS:
  #+BEGIN_export html
  <div class='eval-result'>
  <pre class='res'>&lt;unspecified&gt;</pre>
  <pre class='out'>(+ 1 2 1)
  ;; =&gt; 4
  (/ 10 2)
  ;; =&gt; 5
  </pre>
  <pre class='err'></pre>
  </div>
  #+END_export


  #+BEGIN_SRC scheme
(list 1 2 3)
  #+END_SRC

  #+RESULTS:
  #+BEGIN_export html
  <div class='eval-result'>
  <pre class='res'>(1 2 3)</pre>
  <pre class='out'></pre>
  <pre class='err'></pre>
  </div>
  #+END_export




* COMMENT local vars
  =org-html-htmlize-output-type= also helps with the =*hideshowvis*= problem. (see my blog publishing code as well)
  # Local Variables:
  # org-html-htmlize-output-type: nil
  # End:
  
